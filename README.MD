# ğŸš€ AutomaÃ§Ã£o de Testes Frontend do Softcomshop

Este guia descreve como executar e escrever testes para o Frontend do Softcomshop, utilizando ferramentas modernas para garantir qualidade e eficiÃªncia.

---

## ğŸ›  PrÃ©-requisitos

Para configurar o ambiente de testes, vocÃª precisarÃ¡ dos seguintes componentes:

- **Node.js** (recomendamos a versÃ£o LTS): [Link para download](https://nodejs.org/pt/download/prebuilt-installer)
- **NPM**: Geralmente jÃ¡ Ã© instalado com o Node.js. Para confirmar, execute:
  ```bash
  npm --version
  ```

---

## ğŸ“‹ Passo a Passo de ConfiguraÃ§Ã£o

### 1. ğŸŒ Clonando o RepositÃ³rio

Escolha um diretÃ³rio de fÃ¡cil acesso no seu disco (ex: `C:\Projetos`) e clone o repositÃ³rio executando:

  ```bash
  git clone https://github.com/fabricasoftcom/softcomshop-automacao-frontend.git
  ```

---

### 2. ğŸ“¦ Instalando DependÃªncias

No terminal, navegue atÃ© o diretÃ³rio do projeto e execute o comando abaixo para instalar as dependÃªncias:

  ```bash
  npm install
  ```

---

### 3. âœ… Validando a InstalaÃ§Ã£o do Cypress

Para confirmar a instalaÃ§Ã£o do Cypress, execute:

  ```bash
  npx cypress open
  ```

Isso abrirÃ¡ uma janela do Cypress onde vocÃª poderÃ¡ visualizar e executar todos os testes armazenados no diretÃ³rio `cypress/e2e`.

---

### 4. ğŸƒ Executando os Testes

Para executar todos os testes de uma vez, basta rodar o comando:

  ```bash
  npx cypress run
  ```

---

### ğŸ‰ Pronto para Automatizar!

Agora que seu ambiente estÃ¡ configurado, vocÃª estÃ¡ pronto para executar e criar testes no Softcomshop. Caso tenha alguma dÃºvida ou precise de ajuda, consulte a documentaÃ§Ã£o do Cypress ou entre em contato com a equipe.

---
## ğŸ“ Estrutura do Projeto

### **cypress/e2e**
   - **DescriÃ§Ã£o**: Esta pasta contÃ©m os testes de ponta a ponta, onde cada arquivo representa um cenÃ¡rio ou conjunto de cenÃ¡rios que validam funcionalidades especÃ­ficas da aplicaÃ§Ã£o.
   - **Exemplo de Estrutura**:
     - `login.spec.js`: CenÃ¡rios de teste para login.
     - `cadastro.spec.js`: CenÃ¡rios de teste para cadastro de usuÃ¡rios.
   
### **cypress/support/pages**
   - **DescriÃ§Ã£o**: Esta pasta organiza as classes que representam cada pÃ¡gina da aplicaÃ§Ã£o, centralizando as interaÃ§Ãµes com elementos da interface. Aqui, aplicamos o padrÃ£o Page Objects, encapsulando as aÃ§Ãµes de cada pÃ¡gina para que os testes no Cypress chamem esses mÃ©todos em vez de comandos repetidos.
   - **FunÃ§Ã£o**: Facilita a reutilizaÃ§Ã£o de interaÃ§Ãµes comuns e separa a lÃ³gica dos testes das aÃ§Ãµes especÃ­ficas da interface.
   - **Exemplo de Estrutura**:
     - `LoginPage.js`: MÃ©todos de login como `preencherUsuario()`, `preencherSenha()` e `clicarLogin()`.
     - `CadastroPage.js`: MÃ©todos para preenchimento e submissÃ£o do formulÃ¡rio de cadastro.

### **cypress/support/locators**
   - **DescriÃ§Ã£o**: Local de mapeamento dos elementos de cada pÃ¡gina. Para cada pÃ¡gina da aplicaÃ§Ã£o, criamos uma classe que define e exporta os seletors dos elementos de forma centralizada, facilitando o gerenciamento de mudanÃ§as na interface.
   - **FunÃ§Ã£o**: Permite uma modificaÃ§Ã£o centralizada dos locators quando necessÃ¡rio, sem impacto direto nas classes de pÃ¡gina ou testes.
   - **Exemplo de Estrutura**:
     - `LoginLocators.js`: Exporta seletors como `usuarioInput`, `senhaInput`, e `botaoLogin`.
     - `CadastroLocators.js`: Exporta seletors para os campos do formulÃ¡rio de cadastro.

### **cypress/support/factory**
   - **DescriÃ§Ã£o**: ResponsÃ¡vel pela geraÃ§Ã£o e manipulaÃ§Ã£o de dados de teste para os cenÃ¡rios de automaÃ§Ã£o. Este diretÃ³rio armazena as fÃ¡bricas de dados, facilitando a criaÃ§Ã£o de dados dinÃ¢micos, como usuÃ¡rios, produtos, e outras entidades necessÃ¡rias para a execuÃ§Ã£o dos testes.
   - **FunÃ§Ã£o**: Permite a configuraÃ§Ã£o e geraÃ§Ã£o de dados personalizados para diferentes cenÃ¡rios de teste, aumentando a flexibilidade e robustez dos testes.
   - **Exemplo de Estrutura**:
     - `UserFactory.js`: Gera dados de usuÃ¡rios com atributos aleatÃ³rios para testes de cadastro.
     - `ProductFactory.js`: Cria dados de produtos com propriedades variÃ¡veis para testes de fluxo de compras.

---

## ğŸ“˜ Guia de GitFlow para Nomenclatura de Branches
Este projeto utiliza uma convenÃ§Ã£o de nomenclatura de branches para manter o repositÃ³rio organizado e facilitar o entendimento do propÃ³sito de cada branch. Seguindo essas diretrizes, vocÃª contribuirÃ¡ para um desenvolvimento mais organizado e acessÃ­vel para toda a equipe.

ğŸ”„ Estrutura de Branches
---
### 1. Branches Principais:

- **`main`**  
  - Ã‰ a branch principal e contÃ©m a versÃ£o estÃ¡vel do projeto.
  - Esta branch deve refletir o cÃ³digo em produÃ§Ã£o.
  - **Merges**: Somente `feature`, `chore`, `bugfix`, e `release`.

- **`develop`**  
  - Ã‰ a branch de desenvolvimento onde todas as novas implementaÃ§Ãµes e correÃ§Ãµes sÃ£o integradas.
  - **Merges**: Recebe branches de `feature`, `chore` e `bugfix`.

---

### 2. Branches de Trabalho

Para diferenciar as Ã¡reas de trabalho, utilizamos as seguintes convenÃ§Ãµes:

#### ğŸ§© ConfiguraÃ§Ã£o e Tarefas Convencionais (`chore/`)
   - Usadas para tarefas de configuraÃ§Ã£o e manutenÃ§Ã£o geral, como ajustes em configuraÃ§Ãµes, documentaÃ§Ã£o, CI/CD, dependÃªncias e outras atividades que nÃ£o alteram funcionalidades do sistema.
   - Prefixo: `chore/`
   - **Exemplo**: `chore/atualizar-ci-pipeline` ou `chore/configurar-eslint`

#### âš™ï¸ ImplementaÃ§Ã£o de Testes (`feature/`)
   - Utilizadas para desenvolver novas implementaÃ§Ãµes de testes, seja para novas funcionalidades ou cobertura de testes existente.
   - Prefixo: `feature/`
   - **Exemplo**: `feature/teste-login` ou `feature/teste-validacao-pagamento`

#### ğŸ› CorreÃ§Ã£o de Bug na AutomaÃ§Ã£o (`bugfix/`)
   - Criadas para corrigir bugs encontrados nos scripts de automaÃ§Ã£o.
   - Prefixo: `bugfix/`
   - **Exemplo**: `bugfix/corrigir-teste-login` ou `bugfix/ajuste-flaky-test`

#### â™» RefatoraÃ§Ã£o na AutomaÃ§Ã£o (`refactor/`)
   - Criadas para refatorar funcionalidades/scripts de automaÃ§Ã£o.
   - Prefixo: `refactor/`
   - **Exemplo**: `refactor/implementar-reutilizacao-funcoes-genericas`

---

## ğŸ“Œ Exemplo PrÃ¡tico de Uso

```bash
# Criando uma nova branch para uma tarefa de configuraÃ§Ã£o
git checkout develop
git checkout -b chore/ajustar-config-ci

# Criando uma nova branch para implementaÃ§Ã£o de um teste de funcionalidade
git checkout develop
git checkout -b feature/teste-funcionalidade-pagamento

# Criando uma branch de correÃ§Ã£o de bug na automaÃ§Ã£o
git checkout develop
git checkout -b bugfix/ajustar-teste-autenticacao
```

---

## ğŸ¯ Dicas para um GitFlow Eficiente

- Sempre inicie suas branches a partir da branch `develop`.
- Use **nomes descritivos** para as branches, facilitando o entendimento do propÃ³sito da tarefa.
- ApÃ³s concluir a tarefa, faÃ§a **abertura de PR para a branch `develop`** para manter o fluxo contÃ­nuo de desenvolvimento.

Seguindo esse padrÃ£o, garantimos um fluxo de trabalho eficiente, seguro e organizado ğŸ˜‰!
---
## ğŸš€ Qualidade de CÃ³digo com ESLint + Husky

Este repositÃ³rio utiliza **ESLint** integrado com **Husky** para garantir que todo o cÃ³digo commitado siga as boas prÃ¡ticas de desenvolvimento. ğŸ”âœ¨

### ğŸ”’ Como funciona?
Sempre que vocÃª tentar fazer um `git commit`, o Husky irÃ¡ executar o ESLint automaticamente:
1. O Husky inicia o processo de verificaÃ§Ã£o.
2. O ESLint analisa os arquivos `.js` modificados.
3. Se houver **erros**, o commit serÃ¡ bloqueado e os problemas serÃ£o exibidos no terminal. âŒ
4. VocÃª precisarÃ¡ corrigir os erros antes de tentar novamente. ğŸ› ï¸
5. Se nÃ£o houver erros, o commit serÃ¡ realizado com sucesso! âœ…ğŸ‰

### ğŸ’¡ O que fazer se o commit for bloqueado?
Se o commit nÃ£o for permitido, revise os erros exibidos e corrija-os antes de tentar novamente. VocÃª pode rodar o ESLint manualmente com:
  ```bash
  npm run lint-html
  ```
Ou, para output dos erros direto no terminal:
  ```bash
  npm run lint
  ```
Isso verificarÃ¡ todos os arquivos `.js` no projeto.

### ğŸ› ï¸ Como instalar as dependÃªncias?
Caso vocÃª ainda nÃ£o tenha as dependÃªncias instaladas, basta rodar:
  ```bash
  npm install
  ```
Isso garantirÃ¡ que o ESLint e o Husky estejam funcionando corretamente.

---

## ğŸ·ï¸ Uso de Tags nos Testes

Este projeto utiliza **tags** para organizar e executar cenÃ¡rios de teste especÃ­ficos. ğŸ”–âœ¨

### ğŸ“Œ Como adicionar tags nos testes?
As tags sÃ£o definidas diretamente no `describe` do Cypress, conforme o exemplo:
  ```javascript
  describe('Balanco', { tags: ["@balanco", "@regressivo"] }, () => {
    it('Deve validar o saldo', () => {
      // Teste aqui
    });
  });
  ```
Isso permite que os testes sejam filtrados na execuÃ§Ã£o. ğŸ”

### ğŸš€ Como executar testes filtrando por tags?
VocÃª pode rodar testes especÃ­ficos utilizando a flag `--env grep="@tag"`, por exemplo:
  ```bash
  npx cypress run --env grep="@balanco"
  ```
Isso executarÃ¡ apenas os cenÃ¡rios que possuem a tag `@balanco`.

Se quiser rodar mÃºltiplas tags, use `--env grepTags="all"` para combinar mÃºltiplas tags:
  ```bash
  npx cypress run --env grep="@balanco" --env grepTags="all"
  ```

---

## ğŸ“š DocumentaÃ§Ã£o Oficial
Para mais detalhes, consulte a documentaÃ§Ã£o oficial das ferramentas utilizadas:
- [ESLint](https://eslint.org/docs/latest/user-guide/) ğŸ› ï¸
- [Husky](https://typicode.github.io/husky/#/) ğŸ”—
- [Cypress Grep Plugin (Tags)](https://github.com/cypress-io/cypress-grep) ğŸ“Œ

Com isso, garantimos que todo o cÃ³digo do projeto segue um padrÃ£o de qualidade e que os testes podem ser organizados e executados de forma eficiente! ğŸš€ğŸ”¥

